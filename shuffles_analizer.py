import json
import sys
import os

import graphviz

import words as wd
import shuffle as sh
import diligent_spliffer as dil

def retrieve_json_data(filename):
        with open(filename,'r') as file:
            json_data = json.load(file)
        return json_data

def build_diligent_spliffers(filename):
    folder_name = filename+"_diligent_spliffers"

    if not os.path.exists(folder_name):
        os.makedirs(folder_name)

    #Esto es horrible, lo hago para encontrar el alfabeto a partir del filename
    #El alfabeto suele venir después del número en el formato de nombres que estoy usando
    #e.g. "shuffle_to_5_ab_counterexamples" o "shuffle_to_3_abcd"
    alph=""
    l = filename.split("_")
    for i in range(len(l)):
        if l[i].isalnum():
            alph = l[i+1]
            break

    json_data = retrieve_json_data(filename)
    for thing in json_data:
        try:
            w1 = thing["w1"]
            w2 = thing["w2"]
            w3 = thing["w3"]
            S = dil.diligent_spliffer(w1,w2,w3,alph)
            new_file = folder_name+"/"+w1+"_"+w2+"_"+w3
            S._A.save(new_file,format="dot") #esto no se hace pero no reimplementé awalipy.save en Spliffer
            S._A.save(new_file+".json",format="json")
            graphviz.render('dot','png',new_file)
            os.remove(new_file)
        except (IndexError,TypeError):
            continue

def filter_by(filename,new_filename,function):
    """
    Takes the <filename> of an existing json file, a <new_filename> and
    a boolean <function>. It filters <filename> by the value of <function>
    and dumps the filtered file onto <new_filename>.
    """
    filtered = []

    json_data = retrieve_json_data(filename)
    n = len(json_data)

    for thing in json_data:
        try:
            if function(thing):
                filtered.append(thing)
        except BaseException:
            continue
    
    filtered.insert(0,str(len(filtered))+" elements filtered out of "+str(n)+".")
    json_str = json.dumps(filtered,indent=2)

    with open(new_filename,'w') as file:
        file.write(json_str)

def filter_counterexamples(filename):
    """
    Filters <filename> for all tuples (w1,w2,w3) that have
    been marked with False regarding the commutativity being
    enough to generate all possible ways to shuffle them.

    It dumps the results in '<filename>_counterexamples'.
    """
    filename_counter = filename+"_counterexamples"
    def check_commutativity_not_enough(thing):
        return not thing["commuting_is_enough"]
    filter_by(filename,filename_counter,check_commutativity_not_enough)
    

def filter_essential_counterexamples(filename):
    """
    Filters <filename> for all tuples (w1,w2,w3) that satisfy 
    the following requirements:
     *simple commutativity from a single shuffle is not enough to generate
    all possible shuffles;
     *it's not the case that in all possible shuffles there is the same group
    of Atoms at the beginning or end.
    """
    filename_essential = filename+"_essential"
    def check_commutativity_not_enough_and_essential(thing):
        if thing["commuting_is_enough"]:
            return False
        w1 = thing["w1"]
        w2 = thing["w2"]
        w3 = thing["w3"]
        if sh.are_trim_shuffle(w1,w2,w3):
            return True
    filter_by(filename,filename_essential,check_commutativity_not_enough_and_essential)

def filter_by_unpalindromy(filename):
    new_filename = filename+"_not_palindromic"
    def check_not_palindromic(thing):
        w1 = thing["w1"]
        w2 = thing["w2"]
        w3 = thing["w3"]
        res = True
        if wd.is_palindrome(w1) and wd.is_palindrome(w2) and wd.is_palindrome(w3):
            res = False
        return res
    filter_by(filename,new_filename,check_not_palindromic)

def filter_by_includedness(filename):
    new_filename = filename+"_not_input_included"
    def check_not_included(thing):
        w1 = thing["w1"]
        w2 = thing["w2"]
        return (not (w1 in w2)) and (not (w2 in w1))
    filter_by(filename,new_filename,check_not_included)

def main(option, filename):
    if option == "counterexamples":
        filter_counterexamples(filename)
    elif option == "diligent":
        build_diligent_spliffers(filename)
    elif option == "essential":
        filter_essential_counterexamples(filename)
    elif option == "palindrome":
        filter_by_unpalindromy(filename)
    elif option == "included":
        filter_by_includedness(filename)
    else:
        raise ValueError

try:
    main(sys.argv[1], sys.argv[2])
except BaseException as err:
    print(
        f"Usage:\n python3 {sys.argv[0]} <option> <filename>\n with:\n *<option> can be 'diligent', 'counterexample', 'essential', 'palindrome', 'included'\n *<filename> the name of a json file generated by shuffle_generator and present in this same folder."
    )
    print(
        "If <option> is 'counterexamples' a file called '<filename>_counterexamples' will be generated with the results."
    )
    print(
        "If <option> is 'diligent' a folder called '<filename>_diligent_spliffers' will be created containing all diligent spliffers associated with the file."
    )
    print(
        f"if <option> is 'essential' a file called '<filename>_essential' will be generated with the results."
    )
    print(err)